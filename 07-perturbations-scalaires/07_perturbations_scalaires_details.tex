\subsection{Grille numérique}
On discrétise l’espace \((k,a)\) en posant
\[
  k_{i} \;=\; 10^{-4 \;+\;\frac{i}{N_{k}-1}\,\log_{10}(10^{4})},
  \quad
  i=0,\dots,N_{k}-1,
  \quad
  a_{j} \;=\; 0.1 \;+\;\frac{j}{N_{a}-1}\,(1 - 0.1),
  \quad
  j=0,\dots,N_{a}-1,
\]
avec typiquement \(N_{k}=50\) et \(N_{a}=50\), soit \(N_{k}\times N_{a}=2500\) nœuds \((k_{i},a_{j})\).

\subsection{Accès aux fonctions \(f_{R}(R)\) et \(f_{RR}(R)\)}
Pour chaque facteur d’échelle \(a_{j}\) de la grille, on procède ainsi :
\begin{enumerate}
  \item Calculer le redshift \(z_{j} = 1/a_{j} - 1\).
  \item Interpoler le fichier \texttt{03\_ricci\_vs\_z.csv} pour obtenir la valeur normalisée \(R(z_{j})/R_{0}\).
  \item Interpoler le fichier \texttt{03\_ricci\_fR\_exact.csv} pour récupérer \(f_{R}\bigl(R(z_{j})\bigr)\) et \(f_{RR}\bigl(R(z_{j})\bigr)\).
  \item En déduire \(m_{s}^{2}\bigl(R(z_{j})\bigr)\) via la formule donnée en section « Rappel de \(m_{s}^{2}(R)\) ».
\end{enumerate}

\subsection{Schéma conceptuel du calcul}
Pour chaque nœud \(\bigl(k_{i},a_{j}\bigr)\) de la grille, on procède ainsi :

\begin{enumerate}
  \item \textbf{Interpolation des coefficients :}
    \[
      z_{j} = \frac{1}{a_{j}} - 1,
      \quad
      R_{\mathrm{norm}} = R(z_{j})/R_{0},
    \]
    puis on interpole \(f_{R}=f_{R}(R_{\mathrm{norm}})\) et \(f_{RR}=f_{RR}(R_{\mathrm{norm}})\) à partir des fichiers du Chapitre 3.

  \item \textbf{Calcul de la masse scalaire :}
    \[
      m_{s}^{2}
      = \frac{f_{R} - R_{\mathrm{norm}}\,f_{RR}}{3\,f_{RR}}.
    \]

  \item \textbf{Calcul de la vitesse effective :}
    \[
      c_{s}^{2}(k_{i},a_{j})
      = \frac{f_{R}}{3\,f_{RR}}
        \;\frac{\bigl(k_{i}/a_{j}\bigr)^{2}}{\bigl(k_{i}/a_{j}\bigr)^{2} + m_{s}^{2}}.
    \]

  \item \textbf{Résolution de l’équation de Mukhanov–Sasaki modifiée :}
    \[
      \zeta'' + 2\frac{z'}{z}\,\zeta' + c_{s}^{2}(k_{i},a_{j})\,k_{i}^{2}\,\zeta = 0,
    \]
    avec
    \(\zeta(\eta_{\rm init}) = \frac{1}{\sqrt{2k_{i}}}\),
    \(\zeta'(\eta_{\rm init}) = -i\,\sqrt{\tfrac{k_{i}}{2}}\)
    (conditions de Bunch–Davies en sous-horizon),
    intégrée jusqu’à l’échelle super-horizon.

  \item \textbf{Calcul de la perturbation scalarisée :}
    À l’issue de l’intégration, on note \(\zeta_{\rm fin}\) la valeur finale et on définit
    \[
      \frac{\delta\varphi}{\varphi}(k_{i},a_{j})
      = \frac{f_{R} - R_{\mathrm{norm}}\,f_{RR}}{f_{R}}\;\zeta_{\rm fin}.
    \]

  \item \textbf{Enregistrement des résultats :}
    Sauvegarde dans la table de sortie des valeurs
    \(\{\,k_{i},\,a_{j},\,c_{s}^{2},\,m_{s}^{2},\,\delta\varphi/\varphi\}\).
\end{enumerate}

\subsection{Scripts et exécution numérique}
Tous les scripts nécessaires se trouvent dans le dossier annexe \texttt{../13-scripts-annexes/}.

\paragraph{Dépendances Python}
\texttt{numpy}, \texttt{scipy}, \texttt{pandas}, \texttt{matplotlib}.

\paragraph{Liste des scripts}
\begin{itemize}
  \item \texttt{13\_executer\_scan\_perturbations\_scalaires.py}
        Interpole \(f_{R}\) et \(f_{RR}\), balaie la grille \((k,a)\), calcule \(c_{s}^{2}\), \(m_{s}^{2}\) et \(\delta\varphi/\varphi\), puis génère :
        \texttt{07\_cs2\_scan.csv},
        \texttt{07\_delta\_phi\_phi\_scan.csv},
        \texttt{07\_perturbations\_scalaires\_resultats.csv}.
  \item \texttt{13\_extraire\_extrema.py}
        Extrait et affiche
        \(\min_{(k,a)}c_{s}^{2}\) et \(\max_{(k,a)}(\delta\varphi/\varphi)\)
        depuis \texttt{07\_perturbations\_scalaires\_resultats.csv}.
  \item \texttt{13\_tracer\_carte\_chaleur\_cs2.py}
        Trace et sauvegarde la carte de chaleur de \(c_{s}^{2}(k,a)\) sous
        \texttt{fig\_01\_carte\_chaleur\_cs2\_k\_a.png}.
  \item \texttt{13\_tracer\_carte\_chaleur\_delta\_phi.py}
        Trace et sauvegarde la carte de chaleur de \(\delta\varphi/\varphi\) sous
        \texttt{fig\_02\_carte\_chaleur\_delta\_phi\_k\_a.png}.
\end{itemize}

\paragraph*{Commandes d’exécution}
\begin{enumerate}
  \item Lancer le scan :
\begin{verbatim}
python ../13-scripts-annexes/13_executer_scan_perturbations_scalaires.py \
  --ricci_z ../03-stabilite-fR/03_ricci_vs_z.csv \
  --ricci_fR ../03-stabilite-fR/03_ricci_fR_exact.csv \
  --Nk 50 --Na 50 \
  --output_prefix 07
\end{verbatim}
  \item Extraire les extrema :
\begin{verbatim}
python ../13-scripts-annexes/13_extraire_extrema.py \
  --input 07_perturbations_scalaires_resultats.csv
\end{verbatim}
  \item Tracer la carte de chaleur de \(c_{s}^{2}\) :
\begin{verbatim}
python ../13-scripts-annexes/13_tracer_carte_chaleur_cs2.py \
  --input 07_cs2_scan.csv \
  --output fig_01_carte_chaleur_cs2_k_a.png
\end{verbatim}
  \item Tracer la carte de chaleur de \(\delta\varphi/\varphi\) :
\begin{verbatim}
python ../13-scripts-annexes/13_tracer_carte_chaleur_delta_phi.py \
  --input 07_delta_phi_phi_scan.csv \
  --output fig_02_carte_chaleur_delta_phi_k_a.png
\end{verbatim}
\end{enumerate}

\subsection{Structure détaillée des fichiers CSV}

\paragraph{\texttt{07\_perturbations\_scalaires\_resultats.csv}}
\begin{itemize}
  \item \textbf{Colonnes (dans l’ordre exact, séparées par une virgule sans espace)} :
  \texttt{k, a, c\_s\^2, m\_s\^2/R0, delta\_phi\_over\_phi}
  \item Il y a une ligne par nœud de la grille \((k_{i},a_{j})\) avec \(N_{k}=50\), \(N_{a}=50\), soit 2500 lignes.
  \item Format des valeurs :
  \begin{itemize}
    \item \(k\) : flottant en notation scientifique \texttt{\%1.4e}.
    \item \(a\) : flottant en notation \texttt{\%1.2f}.
    \item \(c_{s}^{2}\) : flottant en notation \texttt{\%1.6f}.
    \item \(m_{s}^{2}/R_{0}\) : flottant en notation \texttt{\%1.6e}.
    \item \(\delta\varphi/\varphi\) : flottant en notation \texttt{\%1.6e}.
  \end{itemize}
  \item Exemple d’extrait (trois lignes) :
    \begin{verbatim}
k,a,cs2,ms2_over_R0,delta_phi_over_phi
1.0000e-04,0.10,0.500123,1.234000e-33,9.000000e-05
1.0000e-04,0.12,0.501000,1.567000e-33,9.500000e-05
1.0000e-04,0.14,0.502345,1.890000e-33,1.000000e-04
    \end{verbatim}
\end{itemize}

\paragraph{\texttt{07\_cs2\_scan.csv}}
\begin{itemize}
  \item \textbf{Colonnes} :
    \[
      k,\;a,\;c_{s}^{2}(k,a).
    \]
  \item Une ligne par nœud \((k_{i},a_{j})\) (50 × 50 = 2500 lignes).
  \item Format des valeurs :
  \begin{itemize}
    \item \(k\) : \texttt{\%1.4e}.
    \item \(a\) : \texttt{\%1.2f}.
    \item \(c_{s}^{2}\) : \texttt{\%1.6f}.
  \end{itemize}
  \item Utilisé exclusivement pour générer la carte de chaleur de \(c_{s}^{2}(k,a)\).
\end{itemize}

\paragraph{\texttt{07\_delta\_phi\_phi\_scan.csv}}
\begin{itemize}
  \item \textbf{Colonnes} :
    \[
      k,\;a,\;\delta\varphi/\varphi(k,a).
    \]
  \item Une ligne par nœud \((k_{i},a_{j})\).
  \item Format des valeurs :
  \begin{itemize}
    \item \(k\) : \texttt{\%1.4e}.
    \item \(a\) : \texttt{\%1.2f}.
    \item \(\delta\varphi/\varphi\) : \texttt{\%1.6e}.
  \end{itemize}
  \item Utilisé pour générer la carte de chaleur de \(\delta\varphi/\varphi\).
\end{itemize}

\subsection*{Exemple d’utilisation du CSV}
Voici un mini‐exemple en Python pour charger le fichier complet et filtrer les données selon \(c_{s}^{2}\)\!:

\begin{verbatim}
import pandas as pd

# Chargement du fichier CSV des résultats
df = pd.read_csv('07_perturbations_scalaires_resultats.csv')

# Afficher les premières lignes
print(df.head())

# Filtrer les nœuds où c_s^2 > 0.6
high_cs2 = df[df['c_s^2'] > 0.6]
print("Nœuds avec c_s^2 > 0.6 :")
print(high_cs2[['k','a','c_s^2']].head())
\end{verbatim}

\subsection{Carte de chaleur de la vitesse effective \(c_{s}^{2}(k,a)\)}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.75\linewidth]
    {07-perturbations-scalaires/fig_01_carte_chaleur_cs2_k_a.png}
  \caption{carte de chaleur de \(c_{s}^{2}(k,a)\) sur
           \((k,a)\in[10^{-4},\,1]\times[0.1,\,1]\).
           L’axe horizontal (log en \(k\)), l’axe vertical (linéaire en \(a\)).
           On constate \(\min c_{s}^{2} \approx 0.50\), confirmant l’absence de modes instables.}
  \label{fig:carte_chaleur_cs2}
\end{figure}

\subsection{Carte de chaleur de la perturbation scalaire \(\delta\varphi/\varphi\)}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.75\linewidth]
    {07-perturbations-scalaires/fig_02_carte_chaleur_delta_phi_k_a.png}
  \caption{carte de chaleur de \(\delta\varphi/\varphi(k,a)\) sur la même grille
           \((k,a)\in[10^{-4},\,1]\times[0.1,\,1]\).
           Le maximum atteint \(\approx 10^{-4}\), bien en dessous du seuil \(10^{-2}\).}
  \label{fig:carte_chaleur_delta_phi}
\end{figure}

\subsection{Conclusion détaillée}
Le scan exhaustif sur la grille
\(\; (k,a)\in[10^{-4},\,1]\times[0.1,\,1]\;\)
montre clairement :
\[
  \min_{(k,a)} c_{s}^{2}(k,a) \simeq 0.50 > 0,
  \qquad
  \max_{(k,a)} \frac{\delta\varphi}{\varphi}(k,a) \simeq 10^{-4} \ll 10^{-2}.
\]
Ainsi, le MCGT est totalement exempt d’instabilités scalaires linéaires sur le domaine considéré.
Les scripts et fichiers décrits garantissent la reproductibilité intégrale des résultats.

\subsection*{Glossaire}

\begin{description}
  \item[$k$] Nombre d’onde comobile, indice discrétisé de la grille, variant de $10^{-4}$ à $1\;h\,\mathrm{Mpc}^{-1}$.
  \item[$a$] Facteur d’échelle cosmologique, variant de $0.1$ à $1$ (période matière-dominée).
  \item[$z$] Redshift associé, $z = 1/a - 1$.
  \item[$R_{\mathrm{norm}}$] $R/R_{0}$, valeur normalisée de la courbure de Ricci ($R_{0}=12H_{0}^{2}$).
  \item[$f_{R}(R)$] Première dérivée de la fonction $f(R)$ par rapport à $R$.
  \item[$f_{RR}(R)$] Seconde dérivée de la fonction $f(R)$ par rapport à $R$.
  \item[$m_{s}^{2}$] Masse scalaire définie par
    $\displaystyle m_{s}^{2}=\frac{f_{R}-R_{\mathrm{norm}}\,f_{RR}}{3\,f_{RR}}$.
  \item[$c_{s}^{2}(k,a)$] Vitesse effective des perturbations scalaires :
    $\displaystyle c_{s}^{2}=\frac{f_{R}}{3f_{RR}}\frac{(k/a)^{2}}{(k/a)^{2}+m_{s}^{2}}$.
  \item[$\zeta(\eta,\mathbf{x})$] Variable de perturbation comobile en jauge comobile.
  \item[$\delta\varphi/\varphi(k,a)$] Fraction de perturbation scalaire normalisée,
    $\displaystyle \frac{\delta\varphi}{\varphi}=\frac{f_{R}-R_{\mathrm{norm}}\,f_{RR}}{f_{R}}\,\zeta_{\rm fin}$.
  \item[Grille $(k_{i},a_{j})$] Ensemble de $N_{k}\times N_{a}=50\times50=2500$ nœuds pour $(k,a)$.
  \item[\texttt{07\_cs2\_scan.csv}] Fichier CSV contenant les valeurs de $c_{s}^{2}(k,a)$ pour chaque nœud.
  \item[\texttt{07\_delta\_phi\_phi\_scan.csv}] Fichier CSV contenant les valeurs de $\delta\varphi/\varphi(k,a)$.
  \item[\texttt{07\_perturbations\_scalaires\_resultats.csv}] Fichier CSV unique combinant $k$, $a$, $c_{s}^{2}$, $m_{s}^{2}/R_{0}$ et $\delta\varphi/\varphi$.
  \item[\texttt{13\_executer\_scan\_perturbations\_scalaires.py}] Script Python principal qui génère tous les fichiers de scan.
  \item[\texttt{13\_extraire\_extrema.py}] Script Python pour extraire et afficher $\min c_{s}^{2}$ et $\max(\delta\varphi/\varphi)$.
  \item[\texttt{13\_tracer\_carte\_chaleur\_cs2.py}] Script Python pour tracer et sauvegarder la carte de chaleur de $c_{s}^{2}(k,a)$.
  \item[\texttt{13\_tracer\_carte\_chaleur\_delta\_phi.py}] Script Python pour tracer et sauvegarder la carte de chaleur de $\delta\varphi/\varphi(k,a)$.
  \item[Département des dépendances]
    Bibliothèques Python requises : \texttt{numpy}, \texttt{scipy}, \texttt{pandas}, \texttt{matplotlib}.
\end{description}


\bigskip
\noindent\emph{Fin de la partie détaillée, Chapitre 7.}

------------------------
---------------------------
---------------------------

\subsection{2. Grille en facteur d’échelle}
La grille en facteur d’échelle est construite selon
\[
  a_j = a_{\min} + j\,\Delta a,\quad
  j=0,\dots, N_a-1,
  \quad \Delta a=\frac{a_{\max}-a_{\min}}{N_a-1}.
\]
Les bornes \(a_{\min},a_{\max}\) et \(N_a\) sont lues depuis
\texttt{07\_params\_perturbations.json} (voir Sect.~2.4 du guide).


\subsection{5. Vitesse du son : \(c_s^2(k,a)\)}
La quantité \(c_s^2\) est calculée via
\[
  c_s^2(k,a)=\frac{\partial p_\phi}{\partial\rho_\phi}(k,a),
\]
dont la mise en œuvre numérique est assurée par la fonction
\texttt{compute\_cs2(k,a,params)} (zz‑scripts/chapitre7/…).
% TODO: insérer la formule fermée issue de la Section théorique 7.x


------------------------------------
----------------------------------------
----------------------------------------
------------------------------------------
---------------------------------------
--------------------------------------
----------------------------------------
-------------------------------------
--------------------------------------

\subsection{Remarque sur les artefacts numériques}

Les figures~\ref{fig:05} et~\ref{fig:06} présentent de très légers « oscillations » et « sauts » ponctuels sur les courbes lissées, que l’on peut attribuer exclusivement aux traitements numériques appliqués et non à un phénomène physique :

\begin{itemize}
  \item \textbf{Interpolation log–log par PCHIP :} pour construire une fonction continue à partir des valeurs discrètes, nous avons utilisé un interpolateur monotone en échelle logaritmique (\texttt{PchipInterpolator}). Cet interpolateur peut créer de petits « plateaux » ou inflexions lorsque les données d’entrée contiennent des transitions abruptes ou de très faibles valeurs (proche de zéro), notamment au‑delà de $k_{\rm split}$.
  \item \textbf{Lissage Savitzky–Golay :} les dérivées $\partial_k\,c_s^2$ (fig.~\ref{fig:05}) et $\partial_k(\delta\phi/\phi)$ subissent un filtrage de type Savitzky–Golay. Ce filtre, bien adapté pour conserver les tendances globales, induit toutefois de fines ondulations autour de certains points (notamment pour $k\sim10^{-1}\,\mathrm{h/Mpc}$). Ces artefacts se manifestent par de petites fluctuations locales qui n’ont aucune signification physique.
  \item \textbf{Précision machine et discretisation :} en régime ultra‑supprimé (dérivée quasi nulle sur plusieurs décennies en basse fréquence), la quantification numérique et la limite de précision produisent un « plancher » proche de zéro, visible comme un palier horizontal avant la montée effective de la courbe.
\end{itemize}

Tous ces effets n’altèrent pas la qualité scientifique des résultats, puisque :
\begin{enumerate}
  \item Les lois de puissance attendues (croissance jusqu’à $k_{\rm split}$ puis décroissance rapide) restent parfaitement lisibles.
  \item Les profiles obtenus correspondent aux prédictions du modèle MCGT en régime super‑horizon et sub‑horizon.
\end{enumerate}

\noindent
\textit{Il conviendra toutefois, dans le texte, de mentionner ces artefacts comme des conséquences du post‑traitement numérique et non comme de nouveaux comportements physiques.}
