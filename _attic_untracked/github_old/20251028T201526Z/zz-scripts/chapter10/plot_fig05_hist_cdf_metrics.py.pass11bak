#!/usr/bin/env python3
from __future__ import annotations
import argparse, textwrap, numpy as np, pandas as pd, matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1.inset_locator import inset_axes, mark_inset
import matplotlib.lines as mlines
def detect_p95_column(df):
    for c in ["p95_20_300_recalc","p95_20_300_circ","p95_20_300_recalced","p95_20_300","p95_circ","p95_recalc","p95"]:
        if c in df.columns: return c
    for c in df.columns:
        if "p95" in c.lower(): return c
    raise KeyError("Aucune colonne 'p95' détectée dans le CSV results.")
def main():
    ap=argparse.ArgumentParser(description="Histogramme + CDF de p95 (circulaire)")
    ap.add_argument("--results", required=True); ap.add_argument("--out", required=True)
    ap.add_argument("--ref-p95", type=float, default=float(np.pi/4)); ap.add_argument("--bins", type=int, default=50)
    ap.add_argument("--dpi", type=int, default=150)
    ap.add_argument("--zoom-x", type=float, default=0.8); ap.add_argument("--zoom-y", type=float, default=35.0)
    ap.add_argument("--zoom-dx", type=float, default=0.30); ap.add_argument("--zoom-dy", type=float, default=30.0)
    ap.add_argument("--zoom-w", type=float, default=0.35); ap.add_argument("--zoom-h", type=float, default=0.22)
    args=ap.parse_args()
    df=pd.read_csv(args.results); p95_col=detect_p95_column(df); p95=df[p95_col].dropna().astype(float).values
    wrapped_corrected=None
    for cand in ("p95_20_300","p95_raw","p95_orig","p95_20_300_raw"):
        if cand in df.columns and cand!=p95_col:
            diff=df[[cand,p95_col]].dropna().astype(float); wrapped_corrected=int((np.abs(diff[cand]-diff[p95_col])>1e-6).sum()); break
    N=p95.size; mean,median,std=float(np.mean(p95)),float(np.median(p95)),float(np.std(p95,ddof=0))
    n_below=int((p95<args.ref_p95).sum()); frac_below=n_below/max(1,N)
    plt.style.use("classic"); fig, ax=plt.subplots(figsize=(14,6))
    counts,bins,patches=ax.hist(p95,bins=args.bins,alpha=0.7,edgecolor="k"); ax.set_ylabel("Effectifs"); ax.set_xlabel(p95_col+" [rad]")
    ax2=ax.twinx(); sorted_p=np.sort(p95); ecdf=np.arange(1,N+1)/N; (cdf_line,)=ax2.plot(sorted_p,ecdf,lw=2)
    ax2.set_ylabel("CDF empirique"); ax2.set_ylim(0.0,1.02)
    ax.axvline(args.ref_p95,color="crimson",linestyle="--",lw=2)
    ax.text(args.ref_p95, ax.get_ylim()[1]*0.45, f"ref = {args.ref_p95:.4f} rad", color="crimson", rotation=90, va="center", ha="right", fontsize=10)
    stat_lines=[f"N = {N}",f"mean = {mean:.3f}",f"median = {median:.3f}",f"std = {std:.3f}"]
    if wrapped_corrected is not None: stat_lines.append(f"wrapped_corrected = {wrapped_corrected}")
    stat_lines.append(f"p(P95 < ref) = {frac_below:.3f} (n={n_below})")
    ax.text(0.02,0.98,"\n".join(stat_lines),transform=ax.transAxes,fontsize=10,va="top",ha="left",
            bbox=dict(boxstyle="round",fc="white",ec="black",lw=1,alpha=0.95))
    patch = patches[0] if len(patches)>0 else None
    if patch is None:
        from matplotlib.patches import Rectangle; patch=Rectangle((0,0),1,1,facecolor="C0",edgecolor="k",alpha=0.7)
    proxy_cdf=mlines.Line2D([],[],color=cdf_line.get_color(),lw=2)
    proxy_ref=mlines.Line2D([],[],color="crimson",linestyle="--",lw=2)
    ax.legend([patch,proxy_cdf,proxy_ref],["Histogramme (effectifs)","CDF empirique","p95 réf"],
              loc="upper left", bbox_to_anchor=(0.02,0.72), frameon=True, fontsize=10)
    inset_ax=inset_axes(ax,width=f"{args.zoom_w*100:.0f}%",height=f"{args.zoom_h*100:.0f}%",loc="center",borderpad=1.0)
    x0,x1=args.zoom_x-args.zoom_dx, args.zoom_x+args.zoom_dx
    mask_x=(p95>=x0)&(p95<=x1); data_inset=p95[mask_x] if mask_x.sum()>=5 else p95
    inset_counts,inset_bins,_=inset_ax.hist(data_inset,bins=min(args.bins,30),alpha=0.9,edgecolor="k")
    ymax_auto=(np.max(inset_counts) if inset_counts.size else 1.0)*1.10; y0=0.0; y1=max(float(args.zoom_y+args.zoom_dy), ymax_auto)
    inset_ax.set_xlim(x0,x1); inset_ax.set_ylim(y0,y1); inset_ax.set_title("zoom",fontsize=10)
    try: mark_inset(ax, inset_ax, loc1=2, loc2=4, fc="none", ec="0.5", lw=0.8)
    except Exception: pass
    ax.set_title(f"Distribution de {p95_col} (MC global)",fontsize=15)
    foot=textwrap.fill((r"Métrique : distance circulaire (mod $2\pi$). "
                        r"p95 = $95^{\mathrm{e}}$ centile de $|\Delta\phi(f)|$ sur $[20,300]$ Hz. "
                        rf"p(\mathrm{{p95}}<\mathrm{{ref}}) = {frac_below:.3f}$ (n = {n_below})."), width=180)
    fig=plt.gcf(); fig.subplots_adjust(left=0,bottom=0.14,right=1,top=0.98); fig=plt.gcf(); fig.text(0.5,0.04,foot,ha="center",va="bottom",fontsize=9)
    fig.savefig(args.out,dpi=args.dpi); print(f"Wrote : {args.out}")
if __name__=="__main__": main()
