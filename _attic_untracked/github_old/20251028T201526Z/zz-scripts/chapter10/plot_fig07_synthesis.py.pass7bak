#!/usr/bin/env python3
from __future__ import annotations
import argparse, json, os, csv, numpy as np, matplotlib.pyplot as plt
from dataclasses import dataclass
from typing import Any, List
from matplotlib.gridspec import GridSpec
def load_manifest(path): 
    with open(path,encoding="utf-8") as f: return json.load(f)
def _first(d, keys, default=np.nan):
    for k in keys:
        if k in d and d[k] is not None: return d[k]
    return default
def _param(params, candidates, default=np.nan): return _first(params, candidates, default)
@dataclass
class Series:
    label: str; N: np.ndarray; coverage: np.ndarray; err_low: np.ndarray; err_high: np.ndarray; width_mean: np.ndarray; alpha: float; params: dict
def series_from_manifest(man, label_override=None):
    results=man.get("results",[])
    if not results: raise ValueError("Manifest ne contient pas de 'results'.")
    N=np.array([_first(r,["N"],np.nan) for r in results],dtype=float)
    coverage=np.array([_first(r,["coverage"],np.nan) for r in results],dtype=float)
    err_low=np.array([_first(r,["coverage_err95_low","coverage_err_low"],0.0) for r in results],dtype=float)
    err_high=np.array([_first(r,["coverage_err95_high","coverage_err_high"],0.0) for r in results],dtype=float)
    width_mean=np.array([_first(r,["width_mean_rad","width_mean"],np.nan) for r in results],dtype=float)
    params=man.get("params",{}); alpha=float(_param(params,["alpha","conf_alpha"],0.05))
    label=label_override or man.get("series_label") or man.get("label") or os.path.basename(man.get("figure_path","")) or "série"
    return Series(label,N,coverage,err_low,err_high,width_mean,alpha,params)
def save_summary_csv(series_list: List[Series], out_csv: str) -> None:
    os.makedirs(os.path.dirname(out_csv) or ".", exist_ok=True)
    fields=["series","N","coverage","err95_low","err95_high","width_mean","outer_B","inner_B","alpha"]
    with open(out_csv,"w",newline="",encoding="utf-8") as f:
        w=csv.DictWriter(f,fieldnames=fields); w.writeheader()
        for s in series_list:
            outer_B=int(_param(s.params,["outer","outer_B","B_outer","outerB","Bouter"],np.nan)) if np.isfinite(_param(s.params,["outer","outer_B","B_outer","outerB","Bouter"],np.nan)) else ""
            inner_B=int(_param(s.params,["inner","inner_B","B_inner","innerB","Binner"],np.nan)) if np.isfinite(_param(s.params,["inner","inner_B","B_inner","innerB","Binner"],np.nan)) else ""
            for i in range(len(s.N)):
                w.writerow({"series":s.label,"N":int(s.N[i]) if np.isfinite(s.N[i]) else "",
                            "coverage":float(s.coverage[i]) if np.isfinite(s.coverage[i]) else "",
                            "err95_low":float(s.err_low[i]) if np.isfinite(s.err_low[i]) else "",
                            "err95_high":float(s.err_high[i]) if np.isfinite(s.err_high[i]) else "",
                            "width_mean":float(s.width_mean[i]) if np.isfinite(s.width_mean[i]) else "",
                            "outer_B":outer_B,"inner_B":inner_B,"alpha":s.alpha})
def plot_synthesis(series_list: List[Series], out_png: str, figsize=(14,6), dpi=300, ymin_cov=None, ymax_cov=None):
    plt.style.use("classic")
    fig=plt.figure(figsize=figsize, constrained_layout=False, dpi=dpi)
    gs=GridSpec(1,2,figure=fig,width_ratios=[5,3],wspace=0.25); ax1=fig.add_subplot(gs[0,0]); ax2=fig.add_subplot(gs[0,1])
    colors=plt.rcParams['axes.prop_cycle'].by_key().get('color', ["tab:blue","tab:orange","tab:green","tab:red"])
    for i,s in enumerate(series_list):
        col=colors[i % len(colors)]
        ax1.errorbar(s.N,s.coverage,yerr=[s.err_low,s.err_high],fmt="o-",lw=1.7,ms=6,color=col,ecolor=col,capsize=3,label=f"{s.label} (α={s.alpha:.2f})")
        ax2.plot(s.N,s.width_mean,"-",lw=2.0,color=col,label=s.label)
    uniq_alpha=set(round(s.alpha,4) for s in series_list if np.isfinite(s.alpha))
    if len(uniq_alpha)==1:
        a=list(uniq_alpha)[0]; ax1.axhline(1-a,color="crimson",ls="--",lw=1.5,label=f"Niveau nominal {int((1-a)*100)}%")
    ax1.set_xlabel("Taille d'échantillon N"); ax1.set_ylabel("Couverture (IC contient la référence)"); ax1.set_title("Couverture vs N")
    if (ymin_cov is not None) or (ymax_cov is not None):
        ymin=ymin_cov if ymin_cov is not None else ax1.get_ylim()[0]; ymax=ymax_cov if ymax_cov is not None else ax1.get_ylim()[1]; ax1.set_ylim(ymin,ymax)
    ax1.legend(loc="lower right", frameon=True)
    ax2.set_xlabel("Taille d'échantillon N"); ax2.set_ylabel("Largeur moyenne de l'IC [rad]"); ax2.set_title("Largeur moyenne d’IC vs N"); ax2.legend(loc="best", frameon=True)
    fig.savefig(out_png,dpi=dpi); print(f"Wrote: {out_png}")
def main():
    ap=argparse.ArgumentParser(description="Synthèse multi-manifests (fig07)")
    ap.add_argument("--manifests", nargs="+", required=True); ap.add_argument("--labels", nargs="*", default=None)
    ap.add_argument("--out", required=True); ap.add_argument("--summary-csv", default=None)
    ap.add_argument("--dpi", type=int, default=300); ap.add_argument("--ymin-coverage", type=float, default=None); ap.add_argument("--ymax-coverage", type=float, default=None)
    args=ap.parse_args()
    if args.labels and len(args.labels)!=len(args.manifests): raise SystemExit("Si --labels est fourni, il doit y en avoir autant que de --manifests.")
    series_list=[]
    for i,path in enumerate(args.manifests):
        man=load_manifest(path); label=args.labels[i] if args.labels else None; series_list.append(series_from_manifest(man,label_override=label))
    if args.summary_csv: save_summary_csv(series_list, args.summary_csv); print(f"[OK] Summary CSV: {args.summary_csv}")
    plot_synthesis(series_list,args.out,dpi=args.dpi,ymin_cov=args.ymin_coverage,ymax_cov=args.ymax_coverage)
if __name__=="__main__": main()
