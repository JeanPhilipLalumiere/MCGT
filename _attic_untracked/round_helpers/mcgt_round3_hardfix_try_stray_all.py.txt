#!/usr/bin/env python3
from __future__ import annotations
import re, time
from pathlib import Path

ROOT = Path.cwd()
TS   = time.strftime("%Y%m%dT%H%M%SZ", time.gmtime())

# On cible *uniquement* la couche scripts/outils, pas le package mcgt/**
ALLOW_PREFIX = (
    "zz-scripts/", "zz-tools/", "zz_tools/", "zz-manifests/", "tools/"
)
EXCLUDE_DIRS = {".git", "__pycache__", ".ci-out", ".mypy_cache", ".tox", "_attic_untracked", "release_zenodo_codeonly"}

def path_allowed(p: Path) -> bool:
    rp = p.as_posix()
    return any(rp.startswith(pref) for pref in ALLOW_PREFIX)

def should_skip(p: Path) -> bool:
    parts = set(p.parts)
    return bool(parts & EXCLUDE_DIRS)

def indent_width(s: str) -> int:
    lead = s[:len(s) - len(s.lstrip(" \t"))]
    return len(lead.expandtabs(4))

def ensure_import_contextlib(lines: list[str]) -> list[str]:
    # insère "import contextlib" après docstring + futures
    head = "".join(lines[:120])
    if ("import contextlib" in head) or ("from contextlib" in head):
        return lines
    i = 0; n = len(lines)
    if i < n and lines[i].startswith("#!"): i += 1
    if i < n and re.match(r'^\s*#\s*-\*-\s*coding:.*-\*-\s*$', lines[i] or ""): i += 1
    triple = re.compile(r'^\s*(?:[rubfRUBF]?){0,2}("""|\'\'\')')
    if i < n and triple.match(lines[i] or ""):
        i += 1
        while i < n and not triple.search(lines[i] or ""):
            i += 1
        if i < n: i += 1
    while i < n and re.match(r'^\s*from\s+__future__\s+import\s+', lines[i] or ""):
        i += 1
    lines[i:i] = ["import contextlib\n"]
    return lines

def fix_future_concatenation(src: str) -> tuple[str,int]:
    # Sépare `from __future__ import annotations` collé à un import suivant
    pat = re.compile(r'(from\s+__future__\s+import\s+annotations)(?=\S)')
    src, n1 = pat.subn(r'\1\n', src)
    pat2 = re.compile(r'(from\s+__future__\s+import\s+annotations);')
    src, n2 = pat2.subn(r'\1\n', src)
    return src, (n1+n2)

def process_file(p: Path) -> tuple[int,int,int]:
    """
    Retourne (n_try_replaced, n_handlers_commented, n_future_fixed)
    """
    try:
        src = p.read_text(encoding="utf-8", errors="ignore")
    except Exception:
        return (0,0,0)

    future_fixed_src, nfut = fix_future_concatenation(src)
    lines = future_fixed_src.splitlines(True)
    n = len(lines)

    # 1) remplace *toutes* les lignes 'try:' par suppress
    ntry = 0
    for i, s in enumerate(lines):
        if s.lstrip().startswith("try:"):
            lead = s[:len(s) - len(s.lstrip(" \t"))]
            lines[i] = f"{lead}with contextlib.suppress(Exception):\n"
            ntry += 1

    # 2) commente tout 'except' / 'finally' et leur bloc
    nrm = 0
    i = 0
    while i < n:
        s = lines[i]
        stripped = s.lstrip()
        if stripped.startswith("except") or stripped.startswith("finally:"):
            lead = s[:len(s) - len(stripped)]
            iw = indent_width(s)
            lines[i] = f"{lead}# [mcgt-fix] STRAY {stripped}"
            nrm += 1
            i += 1
            # commenter le bloc jusqu'au dédent
            while i < n:
                s2 = lines[i]
                if s2.strip() == "":
                    lines[i] = lead + "#\n"
                    i += 1
                    continue
                if indent_width(s2) <= iw:
                    break
                lines[i] = "# " + s2
                i += 1
            continue
        i += 1

    # 3) si on a touché à des try, s'assurer que contextlib est importé
    if ntry > 0:
        lines = ensure_import_contextlib(lines)

    if ntry or nrm or nfut:
        bak = p.with_suffix(p.suffix + f".bak.{TS}")
        bak.write_text(src, encoding="utf-8")
        p.write_text("".join(lines), encoding="utf-8")

    return (ntry, nrm, nfut)

def main():
    scanned = 0; Ttry=Trem=Tfur=0
    for p in ROOT.rglob("*.py"):
        if should_skip(p) or not path_allowed(p) or not p.is_file():
            continue
        scanned += 1
        a,b,c = process_file(p)
        Ttry += a; Trem += b; Tfur += c
    print(f"[hardfix] scanned={scanned}, try_to_suppress={Ttry}, handlers_commented={Trem}, future_fixed={Tfur}")

if __name__ == "__main__":
    main()
