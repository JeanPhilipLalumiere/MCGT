   306	    if (not args.skip_jalons) and jalons_csv is not None and jalons_csv.exists():
   307	        cmd += ["--jalons", str(jalons_csv)]
   308	    if args.overwrite:
   309	        cmd.append("--overwrite")
   310	    run_cmd(cmd, log)
   311	    out_agg = Path(args.results_agg_csv or DEFAULTS["results_agg_csv"])
   312	    best = Path(args.best_json or DEFAULTS["best_json"])
   313	    log.info(
   314	        "   ✓ Résultats agrégés : %s | Top-K final : %s", bref(out_agg), bref(best)
   315	    )
   316	    return (out_agg, best)
   317	
   318	
   319	# ----------------------- Raffinement (option) ------------------------
   320	def _charger_topk(best_json: Path) -> list[dict]:
   321	    bj = load_json(best_json)
   322	    return bj.get("top_k") or bj.get("topK") or []
   323	
   324	
   325	def _calcul_boite_topk(topk: list[dict], shrink: float) -> dict:
   326	    """
   327	    Boîte englobante du top-K sur {m1,m2,q0star,alpha}, resserrée par facteur 'shrink'.
   328	    Stratégie : on prend [min,max] sur le top-K, on recentre à la médiane, et
   329	    on réduit la demi-largeur -> demi_largeur/shrink.
   330	    """
   331	    import numpy as np
   332	
   333	    keys = ["m1", "m2", "q0star", "alpha"]
   334	    out = {}
   335	    for k in keys:
   336	        vals = np.array([float(t[k]) for t in topk if k in t], dtype=float)
   337	        vmin, vmax = float(vals.min()), float(vals.max())
   338	        vmed = float(np.median(vals))
   339	        half = (vmax - vmin) / 2.0
   340	        half = half / max(shrink, 1.0)
   341	        out[k] = {"min": vmed - half, "max": vmed + half}
   342	    return out
   343	
   344	
   345	def _ecrire_config_raffine(
   346	    cfg_base: Path, cfg_out: Path, boite: dict, log: logging.Logger
   347	):
   348	    base = load_json(cfg_base)
   349	    # Adapter les bornes uniquement sur les 4 paramètres libres
   350	    for key in ["m1", "m2", "q0star", "alpha"]:
   351	        if key in base.get("priors", {}):
   352	            base["priors"][key]["min"] = float(boite[key]["min"])
   353	            base["priors"][key]["max"] = float(boite[key]["max"])
   354	    save_json(base, cfg_out)
   355	    log.info("   ↪ Config de raffinement écrite : %s", bref(cfg_out))
   356	
   357	
   358	def _assurer_ids_uniques(samples_path: Path, id_offset: int, log: logging.Logger):
   359	    """
   360	    Re-numérotation simple : id := id + id_offset (garantit unicité lors de fusions).
   361	    """
   362	    import pandas as pd
   363	
   364	from zz_tools import common_io as ci
   365	
   366	    df = pd.read_csv(samples_path)
   367	df = ci.ensure_fig02_cols(df)
   368	
   369	    if "id" not in df.columns:
   370	        raise RuntimeError("Le fichier d'échantillons n'a pas de colonne 'id'.")
   371	    df["id"] = df["id"].astype(int) + int(id_offset)
   372	    tmp = samples_path.with_suffix(".tmp.csv")
   373	    df.to_csv(tmp, index=False, float_format="%.6f")
   374	    os.replace(tmp, samples_path)
   375	    log.info("   ↪ IDs décalés de +%d dans %s", id_offset, bref(samples_path))
   376	
   377	
   378	def etape_6_raffinement(
   379	    args,
   380	    log: logging.Logger,
   381	    best_json_final: Path,
   382	    samples_global: Path,
   383	    results_global: Path,
   384	):
   385	    if not args.refine:
   386	        log.info("6) Raffinement global — SKIP (désactivé)")
   387	        return None
   388	
   389	    log.info("6) Raffinement global autour du top-K (boîte restreinte)")
   390	    topk = _charger_topk(best_json_final)
   391	    if not topk:
   392	        log.warning("   ! Top-K vide : raffinement annulé.")
   393	        return None
   394	
   395	    # 6.1 Boîte englobante restreinte
   396	    boite = _calcul_boite_topk(topk, args.refine_shrink)
   397	    cfg_refine = DDIR / "10_mc_config.refine.json"
   398	    _ecrire_config_raffine(
   399	        Path(args.config or DEFAULTS["config"]), cfg_refine, boite, log
   400	    )
   401	
   402	    # 6.2 Génération des échantillons (raffiné)
   403	    samples_ref = DDIR / "10_mc_samples.refine.csv"
   404	    cmdS = [
   405	        sys.executable,
   406	        str(SCRIPTS["samples"]),
   407	        "--config",
   408	        str(cfg_refine),
   409	        "--n",
   410	        str(args.refine_n),
   411	        "--scheme",
   412	        "sobol",
   413	        "--scramble",
   414	        "on" if args.scramble else "off",
   415	        "--seed",
   416	        str(args.seed),
   417	        "--out",
   418	        str(samples_ref),
   419	        "--overwrite",
   420	    ]
   421	    run_cmd(cmdS, log)
   422	
   423	    # Décaler les ids pour unicité (à partir du max de l'existant)
   424	    import pandas as pd
   425	
   426	    dfG = pd.read_csv(samples_global, usecols=["id"])
