#!/usr/bin/env bash
# ===== Bloc TAG+RELEASE v0.3.6 — SAFE v3.1 (anti-close, JSON propres) =====
TAG="${TAG:-v0.3.6}"
TITLE="${TITLE:-MCGT ${TAG}}"
NOTES="${NOTES:-Release ${TAG} pour déclencher l’archivage Zenodo}"
ATTACH_DIST="${ATTACH_DIST:-1}"   # 1=attacher dist/* si présents
RUN_CHECKS="${RUN_CHECKS:-1}"     # 1=revérifier diag avant tag/release

export TAG

# -- Garde-fou : préférer le vôtre si présent
if [ -f ./garde_fou_universal_v5.sh ]; then
  BLOCK_NAME="tag_release_${TAG}" source ./garde_fou_universal_v5.sh
fi

# -- Garde-fou interne minimal si absent
if ! type run >/dev/null 2>&1; then
  for s in EXIT ERR INT HUP TERM; do trap - "$s" 2>/dev/null || true; done
  unset PROMPT_COMMAND 2>/dev/null || true
  set +e; set +o pipefail 2>/dev/null || true
  mkdir -p _logs
  BLOCK_NAME="tag_release_${TAG}"
  TS="$(date +%Y%m%dT%H%M%S)"
  LOG="_logs/${BLOCK_NAME}_${TS}.log"
  if command -v stdbuf >/dev/null 2>&1; then exec > >(stdbuf -o0 tee -a "$LOG") 2>&1; else exec > >(tee -a "$LOG") 2>&1; fi
  run(){ echo; echo "\$ $*"; "$@"; rc=$?; echo "[rc=$rc] $*"; return $rc; }
  _finish_guard(){ code=$?;
    echo; echo "=== FIN ${BLOCK_NAME} (code=$code) ==="; echo "Log : $LOG";
    if [ -z "${NOPAUSE:-}" ] && [ -t 0 ] && [ -t 1 ]; then read -rp "▶ Entrée pour laisser la fenêtre ouverte... " _ || true
    elif [ -n "${HOLD_ON_EXIT:-}" ]; then echo "[hold] bash interactif (HOLD_ON_EXIT=1) — tapez 'exit' pour quitter."; bash --noprofile --norc -i </dev/tty >/dev/tty 2>&1; fi; }
  trap _finish_guard EXIT
fi

echo "[ctx] branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo '?')"
python -V 2>/dev/null || true
echo "[log] $(date -Is) → ${LOG:-_logs/$(date +%s).log}"

# ---------- 1) Checks (recommandé) ----------
if [ "$RUN_CHECKS" = "1" ]; then
  echo "[refresh] fix_manifest_missing.py --refresh"
  run python tools/fix_manifest_missing.py --refresh

  echo "[diag] capture JSON propres"
  MASTER_JSON="_logs/release_master_${TAG}.json"
  MASTER_ERR="_logs/release_master_${TAG}.stderr"
  PUBL_JSON="_logs/release_publ_${TAG}.json"
  PUBL_ERR="_logs/release_publ_${TAG}.stderr"
  export MASTER_JSON PUBL_JSON   # <<< CORRECTION : exporter pour Python

  # NE PAS utiliser 'run' avec des redirections → JSON propres
  python zz-manifests/diag_consistency.py zz-manifests/manifest_master.json \
    --report json --normalize-paths --apply-aliases --strip-internal --content-check \
    > "$MASTER_JSON" 2> "$MASTER_ERR"

  python zz-manifests/diag_consistency.py zz-manifests/manifest_publication.json \
    --report json --normalize-paths --apply-aliases --strip-internal --content-check \
    > "$PUBL_JSON" 2> "$PUBL_ERR"

  # Compte des erreurs (fallback jq si dispo)
  if command -v jq >/dev/null 2>&1; then
    errs_m="$(jq -r '.errors // 0' "$MASTER_JSON" 2>/dev/null || echo ERR)"
    errs_p="$(jq -r '.errors // 0' "$PUBL_JSON" 2>/dev/null || echo ERR)"
  else
    errs_m="$(python - <<'PY'
import json,os
p=os.environ["MASTER_JSON"]
with open(p,encoding="utf-8") as f: d=json.load(f)
print(d.get("errors", 0))
PY
)"
    errs_p="$(python - <<'PY'
import json,os
p=os.environ["PUBL_JSON"]
with open(p,encoding="utf-8") as f: d=json.load(f)
print(d.get("errors", 0))
PY
)"
  fi
  echo "[diag] master errors=${errs_m} ; publ errors=${errs_p}"

  # Debug en cas d’erreur de parsing
  for f in "$MASTER_JSON" "$MASTER_ERR" "$PUBL_JSON" "$PUBL_ERR"; do
    [ -s "$f" ] || echo "[warn] vide: $(basename "$f")"
  done

  # Si non-vert → on n’exécute pas la release (mais on reste ouvert)
  if ! { [ "$errs_m" = "0" ] && [ "$errs_p" = "0" ]; }; then
    echo "❌ Diag non-verte — on n’exécute pas tag/release."
    echo "   Ouvre : $MASTER_JSON  et  $PUBL_JSON"
    return 0 2>/dev/null || exit 0
  fi
fi

# ---------- 2) Tag ----------
if git rev-parse "${TAG}" >/dev/null 2>&1; then
  echo "[tag] ${TAG} existe déjà — on passe"
else
  run git tag -a "${TAG}" -m "${TITLE}"
  run git push origin "${TAG}"
fi

# ---------- 3) Release GitHub ----------
if command -v gh >/dev/null 2>&1; then
  if gh release view "${TAG}" >/dev/null 2>&1; then
    echo "[release] ${TAG} existe déjà — on passe"
  else
    run gh release create "${TAG}" --title "${TITLE}" --notes "${NOTES}"
  fi
  if [ "${ATTACH_DIST}" = "1" ] && ls dist/* >/dev/null 2>&1; then
    echo "[release] upload dist/* → ${TAG}"
    run gh release upload "${TAG}" dist/* --clobber
  fi
else
  echo "⚠️ gh CLI absente — crée la release via l’UI GitHub (cela déclenchera Zenodo)."
fi

# ---------- 4) Info Zenodo ----------
echo "[zenodo] Avec GitHub↔Zenodo activé, la release ${TAG} déclenche l’archivage."
DOI_LINE=$(grep -m1 '^doi:' CITATION.cff 2>/dev/null | sed 's/^doi:\s*//')
[ -n "$DOI_LINE" ] && echo "[info] doi: $DOI_LINE"

# ===== FIN Bloc TAG+RELEASE v0.3.6 — SAFE v3.1 =====
