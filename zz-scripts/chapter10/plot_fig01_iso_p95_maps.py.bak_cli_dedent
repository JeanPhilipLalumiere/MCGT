#!/usr/bin/env python3
"""
plot_fig01_iso_p95_maps.py
Carte iso-valeurs d'un p95 (ou métrique équivalente) sur (m1, m2) à partir d'un CSV.
- Détection robuste de la colonne p95 (ou --p95-col)
- Tricontours + scatter des échantillons
"""
from __future__ import annotations


def ensure_fig01_cols(df):
    """Charge/valide les colonnes (m1,m2,p95) et retourne un DataFrame nettoyé.
    - Si df est None, lit --results (via args ou argv).
    - Noms par défaut: m1, m2, p95_20_300 (surchargés via args si présents).
    """
    import pandas as pd, sys as _sys
    try:
        args  # fourni par le shim
    except NameError:
        args = None

    # 1) charge df si besoin
    if df is None:
        _res = None
        if args is not None and getattr(args, "results", None):
            _res = args.results
        else:
            av = _sys.argv
            for j,a in enumerate(av):
                if a == "--results" and j+1 < len(av):
                    _res = av[j+1]; break
        if _res is None:
            raise RuntimeError("ensure_fig01_cols: --results introuvable.")
        df = pd.read_csv(_res)

    # 2) noms colonnes
    m1_col  = getattr(args, "m1_col", "m1")  if args else "m1"
    m2_col  = getattr(args, "m2_col", "m2")  if args else "m2"
    p95_col = getattr(args, "p95_col", "p95_20_300") if args else "p95_20_300"

    # 3) validations + cast
    for col in (m1_col, m2_col, p95_col):
        if col not in df.columns:
            raise KeyError(f"Colonne attendue absente: {col}")
    df = df[[m1_col, m2_col, p95_col]].dropna().astype(float)
    if df.shape[0] == 0:
        raise ValueError("Aucune donnée valide après suppression des NaN.")
    return df

# >>> AUTO-ARGS-SHIM >>>
try:
    args
except NameError:
    import argparse as _argparse, sys as _sys
    _shim = _argparse.ArgumentParser(add_help=False)
    # I/O & colonnes
    _shim.add_argument('--results')
    _shim.add_argument('--x-col'); _shim.add_argument('--y-col')
    _shim.add_argument('--sigma-col'); _shim.add_argument('--group-col')
    _shim.add_argument('--n-col'); _shim.add_argument('--p95-col')
    _shim.add_argument('--orig-col'); _shim.add_argument('--recalc-col')
    _shim.add_argument('--m1-col'); _shim.add_argument('--m2-col')
    # Export
    _shim.add_argument('--dpi'); _shim.add_argument('--out')
    _shim.add_argument('--format'); _shim.add_argument('--transparent', action='store_true')
    # Numériques/contrôles divers
    _shim.add_argument('--npoints'); _shim.add_argument('--hires2000', action='store_true')
    _shim.add_argument('--change-eps', dest='change_eps')
    _shim.add_argument('--ref-p95', dest='ref_p95')
    _shim.add_argument('--metric'); _shim.add_argument('--bins'); _shim.add_argument('--alpha')
    _shim.add_argument('--boot-iters', dest='boot_iters'); _shim.add_argument('--seed'); _shim.add_argument('--trim')
    _shim.add_argument('--minN', dest='minN'); _shim.add_argument('--point-size', dest='point_size')
    _shim.add_argument('--zoom-w', dest='zoom_w'); _shim.add_argument('--zoom-h', dest='zoom_h')
    _shim.add_argument('--abs', action='store_true', dest='abs')
    _shim.add_argument('--p95-ref', dest='ref_p95')
    _shim.add_argument('--B', dest='B'); _shim.add_argument('--M', dest='M'); _shim.add_argument('--outer', dest='outer')
    _shim.add_argument('--cmap')
    _shim.add_argument('--zoom-x', dest='zoom_x'); _shim.add_argument('--zoom-dx', dest='zoom_dx')
    _shim.add_argument('--scale-exp', dest='scale_exp')
    _shim.add_argument('--zoom-center-n', dest='zoom_center_n')
    _shim.add_argument('--inner', dest='inner')
    _shim.add_argument('--title', dest='title')
    _shim.add_argument('--zoom-y', dest='zoom_y'); _shim.add_argument('--zoom-dy', dest='zoom_dy')
    _shim.add_argument('--vclip', dest='vclip')
    _shim.add_argument('--angular', action='store_true')
    _shim.add_argument('--hist-scale', dest='hist_scale')
    _shim.add_argument('--threshold', dest='threshold')
    _shim.add_argument('--title-left',  dest='title_left')
    _shim.add_argument('--title-right', dest='title_right')
    _shim.add_argument('--hist-x', dest='hist_x')
    _shim.add_argument('--hist-y', dest='hist_y')
    _shim.add_argument('--figsize')
    # Nouveaux
    _shim.add_argument('--with-zoom', dest='with_zoom', action='store_true')
    _shim.add_argument('--gridsize', dest='gridsize')

    try:
        args, _unk = _shim.parse_known_args(_sys.argv[1:])
    except Exception:
        class _A: pass
        args = _A()

    _DEF = {
        'npoints': 50, 'hires2000': False, 'change_eps': 1e-6, 'ref_p95': 1e9,
        'metric': 'dp95', 'bins': 50, 'alpha': 0.7, 'boot_iters': 2000, 'trim': 0.0,
        'minN': 10, 'point_size': 10.0, 'zoom_w': 1.0, 'zoom_h': 1.0, 'abs': False,
        'B': 2000, 'M': None, 'outer': 500, 'cmap': 'viridis',
        'zoom_x': 0.0, 'zoom_dx': 1.0, 'scale_exp': 0.0,
        'zoom_center_n': None, 'inner': 2000, 'title': 'MCGT figure',
        'zoom_y': 0.0, 'zoom_dy': 1.0, 'vclip': '1,99', 'angular': False,
        'hist_scale': 1.0, 'threshold': 0.0, 'title_left': 'Left panel',
        'title_right': 'Right panel', 'hist_x': 0.0, 'hist_y': 0.0,
        'figsize': '6,4', 'with_zoom': False, 'gridsize': 60,
    }
    for _k, _v in _DEF.items():
        if not hasattr(args, _k) or getattr(args, _k) is None:
            try: setattr(args, _k, _v)
            except Exception: pass

    def _to_int(x):
        try: return int(x)
        except: return x
    def _to_float(x):
        try: return float(x)
        except: return x

    for _k in ('dpi','B','M','outer','bins','boot_iters','npoints','minN','inner','zoom_center_n','gridsize'):
        if hasattr(args,_k): setattr(args,_k, _to_int(getattr(args,_k)))
    for _k in ('alpha','trim','change_eps','point_size','zoom_w','zoom_h','zoom_x','zoom_dx','zoom_y','zoom_dy','scale_exp','hist_scale','threshold','hist_x','hist_y'):
        if hasattr(args,_k): setattr(args,_k, _to_float(getattr(args,_k)))
# <<< AUTO-ARGS-SHIM <<<

import argparse
import sys
import warnings

import matplotlib.pyplot as plt
import matplotlib.tri as tri
import numpy as np
import pandas as pd
from zz_tools import common_io as ci

from matplotlib import colors

# ---------- utilities ----------


def detect_p95_column(df: pd.DataFrame, hint: str | None):
    """Try to find the p95 column using hint or sensible defaults."""
    if hint and hint in df.columns:
        return hint
    candidates = [
        "p95_20_300_recalc",
        "p95_20_300_circ",
        "p95_20_300",
        "p95_circ",
        "p95_recalc",
        "p95",
    ]
    for c in candidates:
        if c in df.columns:
            return c
    for c in df.columns:
        if "p95" in c.lower(): return c
    raise KeyError("Aucune colonne 'p95' détectée dans le fichier results.")


def read_and_validate(path, m1_col=None, m2_col=None, p95_col=None):
    import pandas as pd
    # charge le CSV
    df = pd.read_csv(path)

    cols = list(df.columns)
    lower = {c.lower(): c for c in cols}

    # Résolution m1/m2
    if not m1_col or m1_col not in df.columns:
        m1_col = lower.get('m1', lower.get('mass1', lower.get('x', lower.get('phi0'))))
    if not m2_col or m2_col not in df.columns:
        m2_col = lower.get('m2', lower.get('mass2', lower.get('y', lower.get('phi_ref_fpeak'))))

    # Résolution p95
    if not p95_col or p95_col not in df.columns:
        try:
            # utilise la fonction existante si présente
            p95_col = detect_p95_column(df, p95_col)
        except Exception:
            cands = [c for c in df.columns if 'p95' in c.lower()]
            p95_col = cands[0] if cands else None

    if not m1_col or not m2_col or not p95_col:
        raise KeyError(f"Colonnes introuvables (m1={m1_col}, m2={m2_col}, p95={p95_col}).")

    # Conversion numérique + dropna
    keep = [m1_col, m2_col, p95_col]
    df = df[keep].apply(pd.to_numeric, errors='coerce').dropna()
    if df.shape[0] == 0:
        raise ValueError("Aucune ligne valable après conversion/NaN.")

    # Propager dans args si utile (pour main() qui fait df[args.m1_col]…)
    if 'args' in globals():
        try:
            if getattr(args, 'm1_col', None) is None: args.m1_col = m1_col
            if getattr(args, 'm2_col', None) is None: args.m2_col = m2_col
            if getattr(args, 'p95_col', None) is None: args.p95_col = p95_col
        except Exception:
            pass

    return df
def make_triangulation_and_mask(x, y):
    triang = tri.Triangulation(x, y)
    try:
        tris = triang.triangles
        x1 = x[tris[:, 0]]
        x2 = x[tris[:, 1]]
        x3 = x[tris[:, 2]]
        y1 = y[tris[:, 0]]
        y2 = y[tris[:, 1]]
        y3 = y[tris[:, 2]]
        areas = 0.5 * np.abs((x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1))
        mask = areas <= 0.0
        # triang.set_mask expects boolean mask with same length as triangles
        triang.set_mask(mask)
    except Exception:
        # if something fails, just return triang without extra masking
        pass
    return triang


# ---------- main ----------


def main():
    ap = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    ap.add_argument(
        "--results", required=True, help="CSV results (must contain m1,m2 and p95)."
    )
    ap.add_argument(
        "--p95-col", default=None, help="p95 column name (auto detect if omitted)"
    )
    ap.add_argument("--m1-col", default="m1", help="column name for m1")
    ap.add_argument("--m2-col", default="m2", help="column name for m2")
    ap.add_argument(
        "--out",
        default="zz-figures/chapter10/10_fig_01_iso_p95_mapss.png",
        help="output PNG file",
    )
    ap.add_argument("--levels", type=int, default=16, help="number of contour levels")
    ap.add_argument("--cmap", default="viridis", help="colormap")
    ap.add_argument("--dpi", type=int, default=150, help="png dpi")
    ap.add_argument(
        "--title", default="Carte iso de p95 (m1 vs m2)", help="figure title"
    )
    ap.add_argument(
        "--no-clip",
        action="store_true",
        help="do not clip color scale to percentiles (show full range)",
    )
    args = ap.parse_args()
    try: df_all = pd.read_csv(args.results)
    except Exception as e: print(f"[ERROR] Cannot read '{args.results}': {e}", file=sys.stderr); sys.exit(2)
    try: p95_col = detect_p95_column(df_all, args.p95_col)
    except KeyError as e: print(f"[ERROR] {e}", file=sys.stderr); sys.exit(2)
    try: df = read_and_validate(args.results, args.m1_col, args.m2_col, p95_col)
    except Exception as e: print(f"[ERROR] {e}", file=sys.stderr); sys.exit(2)
    x, y, z = df[args.m1_col].values, df[args.m2_col].values, df[p95_col].values
    triang = make_triangulation_and_mask(x, y)
    zmin, zmax = float(np.nanmin(z)), float(np.nanmax(z))
    if zmax - zmin < 1e-8: zmax = zmin + 1e-6
    levels = np.linspace(zmin, zmax, args.levels)
    vmin, vmax, clipped = zmin, zmax, False
    if not args.no_clip:
        try: p_lo, p_hi = np.percentile(z, [0.1, 99.9])
        except Exception: p_lo, p_hi = zmin, zmax
        if p_hi - p_lo > 1e-8 and (p_lo > zmin or p_hi < zmax):
            vmin, vmax, clipped = float(p_lo), float(p_hi), True
            warnings.warn(f"Clipping [{vmin:.4g}, {vmax:.4g}] (0.1%-99.9%).")
    norm = colors.Normalize(vmin=vmin, vmax=vmax, clip=True)
    plt.style.use("classic")
    fig, ax = plt.subplots(figsize=(10, 8))
    cf = ax.tricontourf(triang, z, levels=levels, cmap=args.cmap, alpha=0.95, norm=norm)
    _cs = ax.tricontour(
        triang, z, levels=levels, colors="k", linewidths=0.45, alpha=0.5
    )

    # scatter overlay (points) - smaller, semi-transparent
    ax.scatter(
        x, y, c="k", s=3, alpha=0.5, edgecolors="none", label="échantillons", zorder=5
    )

    # colorbar (respect the norm)
    cbar = fig.colorbar(cf, ax=ax, shrink=0.8)
    cbar.set_label(f"{p95_col} [rad]")

    ax.set_xlabel(args.m1_col)
    ax.set_ylabel(args.m2_col)

    # title size 15 exactly
    ax.set_title(args.title, fontsize=15)

    # bounding box for full data (small margin)
    xmin, xmax = float(np.min(x)), float(np.max(x))
    ymin, ymax = float(np.min(y)), float(np.max(y))
    xpad = 0.02 * (xmax - xmin) if xmax > xmin else 0.5
    ypad = 0.02 * (ymax - ymin) if ymax > ymin else 0.5
    ax.set_xlim(xmin - xpad, xmax + xpad)
    ax.set_ylim(ymin - ypad, ymax + ypad)

    # small legend
    leg = ax.legend(loc="upper right", frameon=True, fontsize=9)
    leg.set_zorder(20)

    # tight layout and save
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        fig.subplots_adjust(left=0.04, right=0.98, bottom=0.06, top=0.96)

    try:
        fig.savefig(args.out, dpi=args.dpi)
        print(f"Wrote: {args.out}")
        if clipped:
            print(
                "Note: color scaling was clipped to percentiles (0.1%/99.9%). Use --no-clip to disable clipping."
            )
    except Exception as e:
        print(f"[ERROR] cannot write output file '{args.out}': {e}", file=sys.stderr)
        sys.exit(2)


if __name__ == "__main__":
    main()
