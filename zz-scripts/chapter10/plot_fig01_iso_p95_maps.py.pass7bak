#!/usr/bin/env python3
"""
plot_fig01_iso_p95_maps.py
Carte iso-valeurs d'un p95 (ou métrique équivalente) sur (m1, m2) à partir d'un CSV.
- Détection robuste de la colonne p95 (ou --p95-col)
- Tricontours + scatter des échantillons
"""
from __future__ import annotations
import argparse, sys, warnings
import numpy as np, pandas as pd, matplotlib.pyplot as plt, matplotlib.tri as tri
from matplotlib import colors
def detect_p95_column(df: pd.DataFrame, hint: str | None):
    if hint and hint in df.columns: return hint
    for c in ["p95_20_300_recalc","p95_20_300_circ","p95_20_300","p95_circ","p95_recalc","p95"]:
        if c in df.columns: return c
    for c in df.columns:
        if "p95" in c.lower(): return c
    raise KeyError("Aucune colonne 'p95' détectée dans le fichier results.")
def read_and_validate(path, m1_col, m2_col, p95_col):
    try: df = pd.read_csv(path)
    except Exception as e: raise SystemExit(f"Erreur lecture CSV '{path}': {e}")
    for col in (m1_col, m2_col, p95_col):
        if col not in df.columns: raise KeyError(f"Colonne attendue absente: {col}")
    df = df[[m1_col, m2_col, p95_col]].dropna().astype(float)
    if df.shape[0] == 0: raise ValueError("Aucune donnée valide après suppression des NaN.")
    return df
def make_triangulation_and_mask(x, y):
    triang = tri.Triangulation(x, y)
    try:
        tris = triang.triangles
        x1, x2, x3 = x[tris[:,0]], x[tris[:,1]], x[tris[:,2]]
        y1, y2, y3 = y[tris[:,0]], y[tris[:,1]], y[tris[:,2]]
        areas = 0.5 * np.abs((x2-x1)*(y3-y1) - (x3-x1)*(y2-y1))
        triang.set_mask(areas <= 0.0)
    except Exception: pass
    return triang
def main():
    ap = argparse.ArgumentParser(description="Carte iso de p95 (m1 vs m2)")
    ap.add_argument("--results", required=True)
    ap.add_argument("--out", required=True)
    ap.add_argument("--p95-col", default=None)
    ap.add_argument("--m1-col", default="m1"); ap.add_argument("--m2-col", default="m2")
    ap.add_argument("--levels", type=int, default=12)
    ap.add_argument("--no-clip", action="store_true")
    ap.add_argument("--cmap", default="viridis")
    ap.add_argument("--dpi", type=int, default=150)
    ap.add_argument("--title", default="Carte iso de p95 (m1 vs m2)")
    args = ap.parse_args()
    try: df_all = pd.read_csv(args.results)
    except Exception as e: print(f"[ERROR] Cannot read '{args.results}': {e}", file=sys.stderr); sys.exit(2)
    try: p95_col = detect_p95_column(df_all, args.p95_col)
    except KeyError as e: print(f"[ERROR] {e}", file=sys.stderr); sys.exit(2)
    try: df = read_and_validate(args.results, args.m1_col, args.m2_col, p95_col)
    except Exception as e: print(f"[ERROR] {e}", file=sys.stderr); sys.exit(2)
    x, y, z = df[args.m1_col].values, df[args.m2_col].values, df[p95_col].values
    triang = make_triangulation_and_mask(x, y)
    zmin, zmax = float(np.nanmin(z)), float(np.nanmax(z))
    if zmax - zmin < 1e-8: zmax = zmin + 1e-6
    levels = np.linspace(zmin, zmax, args.levels)
    vmin, vmax, clipped = zmin, zmax, False
    if not args.no_clip:
        try: p_lo, p_hi = np.percentile(z, [0.1, 99.9])
        except Exception: p_lo, p_hi = zmin, zmax
        if p_hi - p_lo > 1e-8 and (p_lo > zmin or p_hi < zmax):
            vmin, vmax, clipped = float(p_lo), float(p_hi), True
            warnings.warn(f"Clipping [{vmin:.4g}, {vmax:.4g}] (0.1%–99.9%).")
    norm = colors.Normalize(vmin=vmin, vmax=vmax, clip=True)
    plt.style.use("classic")
    fig, ax = plt.subplots(figsize=(10, 8))
    cf = ax.tricontourf(triang, z, levels=levels, cmap=args.cmap, alpha=0.95, norm=norm)
    ax.tricontour(triang, z, levels=levels, colors="k", linewidths=0.45, alpha=0.5)
    ax.scatter(x, y, c="k", s=3, alpha=0.5, edgecolors="none", label="échantillons", zorder=5)
    cbar = fig.colorbar(cf, ax=ax, shrink=0.8); cbar.set_label(f"{p95_col} [rad]")
    ax.set_xlabel(args.m1_col); ax.set_ylabel(args.m2_col); ax.set_title(args.title, fontsize=15)
    xmin, xmax = float(np.min(x)), float(np.max(x)); ymin, ymax = float(np.min(y)), float(np.max(y))
    xpad = 0.02 * (xmax - xmin) if xmax > xmin else 0.5; ypad = 0.02 * (ymax - ymin) if ymax > ymin else 0.5
    ax.set_xlim(xmin - xpad, xmax + xpad); ax.set_ylim(ymin - ypad, ymax + ypad)
    leg = ax.legend(loc="upper right", frameon=True, fontsize=9); leg.set_zorder(20)
    with warnings.catch_warnings():
        warnings.simplefilter("ignore"); plt.tight_layout()
    try:
        fig.savefig(args.out, dpi=args.dpi); print(f"Wrote: {args.out}")
        if clipped: print("Note: color scaling clipped. Use --no-clip to disable.")
    except Exception as e:
        print(f"[ERROR] cannot write '{args.out}': {e}", file=sys.stderr); sys.exit(2)
if __name__ == "__main__": main()
