#!/usr/bin/env python3
from __future__ import annotations
# --- cli global proxy v7 ---
import sys as _sys, types as _types, re as _re
try:
    args  # noqa: F821  # peut ne pas exister
except NameError:
    args = _types.SimpleNamespace()

_COMMON_DEFAULTS = {
    'p95_col': None,
    'm1_col': 'phi0',
    'm2_col': 'phi_ref_fpeak',
    'hires2000': False,
    'metric': 'dp95',
    'mincnt': 1,
    'gridsize': 60,
    'figsize': '8,6',
    'dpi': 300,
    'title': '',
    'title_left': '',
    'title_right': '',
    'hist_x': 0,
    'hist_y': 0,
    'hist_scale': 1.0,
    'with_zoom': False,
    'zoom_x': None,
    'zoom_y': None,
    'zoom_dx': None,
    'zoom_dy': None,
    'zoom_center_n': None,
    'cmap': 'viridis',
    'point_size': 10,
    'threshold': 0.0,
    'angular': False,
    'vclip': '0,100',
    'minN': 10,
    'scale_exp': 0,
    'ymin_coverage': 0.0,
    'ymax_coverage': 1.0,
}

def _v7_from_argv(flag_name: str):
    flag = '--' + flag_name.replace('_','-')
    for i,a in enumerate(_sys.argv):
        if a == flag and i+1 < len(_sys.argv):
            return _sys.argv[i+1]
        if a.startswith(flag + '='):
            return a.split('=',1)[1]
        if a == flag:
            return True
        if a == '--no-' + flag_name.replace('_','-'):
            return False
    return None

def _v7_cast(val):
    if isinstance(val, (bool, int, float)) or val is None:
        return val
    s = str(val)
    sl = s.lower()
    if sl in ('true','yes','y','1'): return True
    if sl in ('false','no','n','0'): return False
    try:
        if any(ch in s for ch in ('.','e','E')):
            return float(s)
        return int(s)
    except Exception:
        return s

class _ArgsProxy:
    def __init__(self, base):
        object.__setattr__(self, '_base', base)
    def __getattr__(self, name):
        if hasattr(self._base, name):
            return getattr(self._base, name)
        v = _v7_from_argv(name)
        if v is None:
            v = _COMMON_DEFAULTS.get(name, None)
        else:
            v = _v7_cast(v)
        setattr(self._base, name, v)
        return v
    def __setattr__(self, name, value):
        if name == '_base':
            object.__setattr__(self, name, value)
        else:
            setattr(self._base, name, value)
args = _ArgsProxy(args)
# --- end cli global proxy v7 ---

# --- cli global proxy v7 coalesce defaults ---
try:
    args
except NameError:
    pass
else:
    if getattr(args, 'npoints', None) is None: args.npoints = 50
    if getattr(args, 'minN', None) is None: args.minN = 10
# --- end cli global proxy v7 coalesce defaults ---


# --- cli global proxy v7 local tweak ---
try:
    args
except NameError:
    pass
else:
    if not hasattr(args, 'npoints'): args.npoints = 50
# --- end cli global proxy v7 local tweak ---

# --- cli global backfill v6 ---
import sys as _sys, types as _types
try:
    args  # noqa: F821  # peut ne pas exister
except NameError:
    args = _types.SimpleNamespace()

def _v6_arg_or_default(flag: str, default):
    # priorité au CLI si présent (sans supposer que le parser connaît le flag)
    for _j, _a in enumerate(_sys.argv):
        if _a == flag and _j + 1 < len(_sys.argv):
            return _sys.argv[_j + 1]
    return default

if not hasattr(args, 'm1_col'):
    args.m1_col = _v6_arg_or_default('--m1-col', 'phi0')
if not hasattr(args, 'm2_col'):
    args.m2_col = _v6_arg_or_default('--m2-col', 'phi_ref_fpeak')
# --- end cli global backfill v6 ---

"""
plot_fig06_residual_map.py  -  Figure 6 finale

- Carte hexbin des résidus sur (m1,m2) avec réduction par médiane.
- Colorbar pré-scalée (affiche en ×10^exp rad ; défaut exp=-7).

Exemple :
python zz-scripts/chapter10/plot_fig06_residual_map.py \
  --results zz-data/chapter10/10_mc_results.circ.csv \
  --metric dp95 --abs --m1-col m1 --m2-col m2 \
  --orig-col p95_20_300 --recalc-col p95_20_300_recalc \
  --gridsize 36 --mincnt 3 --cmap viridis --vclip 1,99 \
  --scale-exp -7 --threshold 1e-6 \
  --figsize 15,9 --dpi 300 --manifest \
  --out zz-figures/chapter10/10_fig_06_heatmap_absdp95_m1m2.png
"""








# --- compat: ensure args.m1_col/m2_col exist ---
if 'args' in globals() and not hasattr(args, 'm1_col'):
    args.m1_col = 'phi0'
if 'args' in globals() and not hasattr(args, 'm2_col'):
    args.m2_col = 'phi_ref_fpeak'


# --- AUTO-FALLBACKS (ch10: fig06) ---
try:
    args
except NameError:
    from argparse import Namespace as _NS
    args = _NS()
if not hasattr(args, 'mincnt'): args.mincnt = 1
if not hasattr(args, 'gridsize'): args.gridsize = 60
if not hasattr(args, 'figsize'): args.figsize = '6,5'
# --- END AUTO-FALLBACKS (ch10: fig06) ---

# >>> AUTO-ARGS-SHIM >>>
try:
    args
except NameError:
    import argparse as _argparse, sys as _sys
    _shim = _argparse.ArgumentParser(add_help=False)
    # I/O & colonnes
    _shim.add_argument('--results')
    _shim.add_argument('--x-col'); _shim.add_argument('--y-col')
    _shim.add_argument('--sigma-col'); _shim.add_argument('--group-col')
    _shim.add_argument('--n-col'); _shim.add_argument('--p95-col')
    _shim.add_argument('--orig-col'); _shim.add_argument('--recalc-col')
    _shim.add_argument('--m1-col'); _shim.add_argument('--m2-col')
    # Export
    _shim.add_argument('--dpi'); _shim.add_argument('--out')
    _shim.add_argument('--format'); _shim.add_argument('--transparent', action='store_true')
    # Numériques/contrôles divers
    _shim.add_argument('--npoints'); _shim.add_argument('--hires2000', action='store_true')
    _shim.add_argument('--change-eps', dest='change_eps')
    _shim.add_argument('--ref-p95', dest='ref_p95')
    _shim.add_argument('--metric'); _shim.add_argument('--bins'); _shim.add_argument('--alpha')
    _shim.add_argument('--boot-iters', dest='boot_iters'); _shim.add_argument('--seed'); _shim.add_argument('--trim')
    _shim.add_argument('--minN', dest='minN'); _shim.add_argument('--point-size', dest='point_size')
    _shim.add_argument('--zoom-w', dest='zoom_w'); _shim.add_argument('--zoom-h', dest='zoom_h')
    _shim.add_argument('--abs', action='store_true', dest='abs')
    _shim.add_argument('--p95-ref', dest='ref_p95')
    _shim.add_argument('--B', dest='B'); _shim.add_argument('--M', dest='M'); _shim.add_argument('--outer', dest='outer')
    _shim.add_argument('--cmap')
    _shim.add_argument('--zoom-x', dest='zoom_x'); _shim.add_argument('--zoom-dx', dest='zoom_dx')
    _shim.add_argument('--scale-exp', dest='scale_exp')
    _shim.add_argument('--zoom-center-n', dest='zoom_center_n')
    _shim.add_argument('--inner', dest='inner')
    _shim.add_argument('--title', dest='title')
    _shim.add_argument('--zoom-y', dest='zoom_y'); _shim.add_argument('--zoom-dy', dest='zoom_dy')
    _shim.add_argument('--vclip', dest='vclip')
    _shim.add_argument('--angular', action='store_true')
    _shim.add_argument('--hist-scale', dest='hist_scale')
    _shim.add_argument('--threshold', dest='threshold')
    _shim.add_argument('--title-left',  dest='title_left')
    _shim.add_argument('--title-right', dest='title_right')
    _shim.add_argument('--hist-x', dest='hist_x')
    _shim.add_argument('--hist-y', dest='hist_y')
    _shim.add_argument('--figsize')
    # Nouveaux
    _shim.add_argument('--with-zoom', dest='with_zoom', action='store_true')
    _shim.add_argument('--gridsize', dest='gridsize')

    try:
        args, _unk = _shim.parse_known_args(_sys.argv[1:])
        # --- cli post-parse backfill (auto v2) ---
        import sys as _sys  # backfill
        try:
            args.m1_col
        except AttributeError:
            _val = None
            for _j, _a in enumerate(_sys.argv):
                if _a == '--m1-col' and _j + 1 < len(_sys.argv):
                    _val = _sys.argv[_j + 1]
                    break
            if _val is None:
                args.m1_col = 'phi0'
            else:
                args.m1_col = _val
        try:
            args.m2_col
        except AttributeError:
            _val = None
            for _j, _a in enumerate(_sys.argv):
                if _a == '--m2-col' and _j + 1 < len(_sys.argv):
                    _val = _sys.argv[_j + 1]
                    break
            if _val is None:
                args.m2_col = 'phi_ref_fpeak'
            else:
                args.m2_col = _val
        # --- end cli post-parse backfill (auto v2) ---
    except Exception:
        class _A: pass
        args = _A()

    _DEF = {
        'npoints': 50, 'hires2000': False, 'change_eps': 1e-6, 'ref_p95': 1e9,
        'metric': 'dp95', 'bins': 50, 'alpha': 0.7, 'boot_iters': 2000, 'trim': 0.0,
        'minN': 10, 'point_size': 10.0, 'zoom_w': 1.0, 'zoom_h': 1.0, 'abs': False,
        'B': 2000, 'M': None, 'outer': 500, 'cmap': 'viridis',
        'zoom_x': 0.0, 'zoom_dx': 1.0, 'scale_exp': 0.0,
        'zoom_center_n': None, 'inner': 2000, 'title': 'MCGT figure',
        'zoom_y': 0.0, 'zoom_dy': 1.0, 'vclip': '1,99', 'angular': False,
        'hist_scale': 1.0, 'threshold': 0.0, 'title_left': 'Left panel',
        'title_right': 'Right panel', 'hist_x': 0.0, 'hist_y': 0.0,
        'figsize': '6,4', 'with_zoom': False, 'gridsize': 60,
    }
    for _k, _v in _DEF.items():
        if not hasattr(args, _k) or getattr(args, _k) is None:
            try: setattr(args, _k, _v)
            except Exception: pass

    def _to_int(x):
        try: return int(x)
        except: return x
    def _to_float(x):
        try: return float(x)
        except: return x

    for _k in ('dpi','B','M','outer','bins','boot_iters','npoints','minN','inner','zoom_center_n','gridsize'):
        if hasattr(args,_k): setattr(args,_k, _to_int(getattr(args,_k)))
    for _k in ('alpha','trim','change_eps','point_size','zoom_w','zoom_h','zoom_x','zoom_dx','zoom_y','zoom_dy','scale_exp','hist_scale','threshold','hist_x','hist_y'):
        if hasattr(args,_k): setattr(args,_k, _to_float(getattr(args,_k)))
# <<< AUTO-ARGS-SHIM <<<

import argparse
import json
import os

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from zz_tools import common_io as ci

from matplotlib.ticker import MaxNLocator


# ------------------------- utilitaires -------------------------------------
def wrap_pi(x: np.ndarray) -> np.ndarray:
    """Ramène les angles en radians dans (-π, π]."""
    return (x + np.pi) % (2 * np.pi) - np.pi


def detect_col(df: pd.DataFrame, candidates: list[str]) -> str:
    """Trouve une colonne par nom exact ou par inclusion insensible à la casse."""
    for c in candidates:
        if c and c in df.columns: return c
    for c in df.columns:
        lc=c.lower()
        for cand in candidates:
            if cand and cand.lower() in lc: return c
    raise KeyError(f"Impossible de trouver l'une des colonnes : {candidates}")


# --------------------------- script principal ------------------------------
def main():
    ap = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    ap.add_argument("--results", required=True, help="CSV d'entrée.")
    ap.add_argument("--metric", choices=["dp95", "dphi"], default="dp95")
    ap.add_argument("--abs", action="store_true", help="Prendre la valeur absolue.")
    ap.add_argument("--m1-col", default="m1")
    ap.add_argument("--m2-col", default="m2")
    ap.add_argument(
        "--orig-col", default="p95_20_300", help="Colonne p95 originale (dp95)."
    )
    ap.add_argument(
        "--recalc-col",
        default="p95_20_300_recalc",
        help="Colonne p95 recalculée (dp95).",
    )
    ap.add_argument("--phi-ref-col", default=None, help="Colonne phi_ref (dphi).")
    ap.add_argument("--phi-mcgt-col", default=None, help="Colonne phi_mcgt (dphi).")
    ap.add_argument("--gridsize", type=int, default=36)
    ap.add_argument(
        "--mincnt", type=int, default=3, help="Masque les hexagones avec nb<mincnt."
    )
    ap.add_argument("--cmap", default="viridis")
    ap.add_argument(
        "--vclip", default="1,99", help="Percentiles pour vmin,vmax (ex: '1,99')."
    )
    ap.add_argument(
        "--scale-exp", type=int, default=-7, help="Exponent pour l'échelle ×10^exp rad."
    )
    ap.add_argument(
        "--threshold",
        type=float,
        default=1e-6,
        help="Seuil pour fraction |metric|>threshold [rad].",
    )
    ap.add_argument(
        "--figsize", default="15,9", help="Largeur,hauteur en pouces (ex: '15,9')."
    )
    ap.add_argument("--dpi", type=int, default=300)
    ap.add_argument("--out", default="fig_06_residual_map.png")
    ap.add_argument("--manifest", action="store_true")
    args = ap.parse_args()
    # --- cli post-parse backfill (auto v2) ---
    import sys as _sys  # backfill
    try:
        args.m1_col
    except AttributeError:
        _val = None
        for _j, _a in enumerate(_sys.argv):
            if _a == '--m1-col' and _j + 1 < len(_sys.argv):
                _val = _sys.argv[_j + 1]
                break
        if _val is None:
            args.m1_col = 'phi0'
        else:
            args.m1_col = _val
    try:
        args.m2_col
    except AttributeError:
        _val = None
        for _j, _a in enumerate(_sys.argv):
            if _a == '--m2-col' and _j + 1 < len(_sys.argv):
                _val = _sys.argv[_j + 1]
                break
        if _val is None:
            args.m2_col = 'phi_ref_fpeak'
        else:
            args.m2_col = _val
    # --- end cli post-parse backfill (auto v2) ---

    # ------------------------------------------------------------------ data
    df = pd.read_csv(args.results).dropna(subset=[args.m1_col, args.m2_col])
try:
    df
except NameError:
    import pandas as _pd
    _res = None
    try:
        _res = args.results
    except Exception:
        import sys as _sys
        for _j,_a in enumerate(_sys.argv):
            if _a == "--results" and _j+1 < len(_sys.argv):
                _res = _sys.argv[_j+1]
                break
    if _res is None:
        raise RuntimeError("Cannot infer --results (no args and no --results in argv)")
    df = _pd.read_csv(_res)
df = ci.ensure_fig02_cols(df)
x = df[args.m1_col].astype(float).values
y = df[args.m2_col].astype(float).values
N = len(df)

if args.metric == "dp95":
        col_o = detect_col(df, [args.orig_col, "p95_20_300", "p95"])
        col_r = detect_col(df, [args.recalc_col, "p95_20_300_recalc", "p95_recalc"])
        raw = df[col_r].astype(float).values - df[col_o].astype(float).values
        metric_name = r"\Delta p_{95}"
else:  # dphi
        col_ref = detect_col(df, [args.phi_ref_col or "phi_ref_fpeak"])
        col_mc = detect_col(df, [args.phi_mcgt_col or "phi_mcgt_fpeak", "phi_mcgt"])
        raw = wrap_pi(
            df[col_mc].astype(float).values - df[col_ref].astype(float).values
        )
        metric_name = r"\Delta \phi"

if args.abs:
        raw = np.abs(raw)
        metric_label = rf"|{metric_name}|"
else:
        metric_label = rf"{metric_name}"

    # Pré-scaling pour l'affichage : valeurs en unités "×10^exp rad"
scale_factor = 10.0**args.scale_exp
scaled = raw / scale_factor

    # vmin/vmax via percentiles sur *scaled*
p_lo, p_hi = (float(t) for t in args.vclip.split(","))
vmin = float(np.percentile(scaled, p_lo))
vmax = float(np.percentile(scaled, p_hi))

    # Stats globales (sur scaled) + fraction > threshold (non-scalé)
med = float(np.median(scaled))
mean = float(np.mean(scaled))
std = float(np.std(scaled, ddof=0))
p95 = float(np.percentile(scaled, 95.0))
frac_over = float(np.mean(np.abs(raw) > args.threshold))

    # ------------------------------ figure & axes ---------------------------
fig_w, fig_h = (float(s) for s in args.figsize.split(","))
plt.style.use("classic")
fig = plt.figure(figsize=(fig_w, fig_h), dpi=args.dpi)

    # -> plus d'espace horizontal entre carte/colorbar et inserts (left=0.75)
    # -> moins d'espace vertical avec le footer (bottom abaissé)
ax_main = fig.add_axes([0.07, 0.145, 0.56, 0.74])  # left, bottom, width, height
ax_cbar = fig.add_axes([0.645, 0.145, 0.025, 0.74])
right_left = 0.75
right_w = 0.23
ax_cnt = fig.add_axes([right_left, 0.60, right_w, 0.30])
ax_hist = fig.add_axes([right_left, 0.20, right_w, 0.30])

    # ------------------------------- main hexbin ---------------------------
hb = ax_main.hexbin(
        x,
        y,
        C=scaled,
        gridsize=args.gridsize,
        reduce_C_function=np.median,
        mincnt=args.mincnt,
        vmin=vmin,
        vmax=vmax,
        cmap=args.cmap,
    )
cbar = fig.colorbar(hb, cax=ax_cbar)
exp_txt = f"× 10^{args.scale_exp}"  # ex: × 10^-7
cbar.set_label(rf"{metric_label} {exp_txt} [rad]")

ax_main.set_title(
        rf"Carte des résidus ${metric_label}$ sur $(m_1,m_2)$"
        + (" (absolu)" if args.abs else "")
    )
ax_main.set_xlabel("m1")
ax_main.set_ylabel("m2")

    # annotation mincnt
ax_main.text(
        0.02,
        0.02,
        f"Hexagones vides = count < {args.mincnt}",
        transform=ax_main.transAxes,
        ha="left",
        va="bottom",
        bbox=dict(boxstyle="round", fc="white", ec="0.5", alpha=0.9),
        fontsize=9,
    )

    # ------------------------------- counts inset --------------------------
hb_counts = ax_cnt.hexbin(x, y, gridsize=args.gridsize, cmap="gray_r")
cbar_cnt = fig.colorbar(
        hb_counts, ax=ax_cnt, orientation="vertical", fraction=0.046, pad=0.03
    )
cbar_cnt.set_label("Counts")
ax_cnt.set_title("Counts (par cellule)")
ax_cnt.set_xlabel("m1")
ax_cnt.set_ylabel("m2")
ax_cnt.xaxis.set_major_locator(MaxNLocator(nbins=5))
ax_cnt.yaxis.set_major_locator(MaxNLocator(nbins=5))

    # n_active = somme des points contenus dans les cellules ayant count >= mincnt
counts_arr = hb_counts.get_array()
n_active = int(np.sum(counts_arr[counts_arr >= args.mincnt]))

    # ------------------------------- histogram inset -----------------------
ax_hist.hist(scaled, bins=40, color="#1f77b4", edgecolor="black", linewidth=0.6)
ax_hist.set_title("Distribution globale")
ax_hist.set_xlabel(rf"metric {exp_txt} [rad]")
ax_hist.set_ylabel("fréquence")

    # Boîte de stats (3 lignes)
stats_lines = [
        rf"median={med:.2f}, mean={mean:.2f}",
        rf"std={std:.2f}, p95={p95:.2f} {exp_txt} [rad]",
        rf"fraction |metric|>{args.threshold:.0e} rad = {100 * frac_over:.2f}%",
    ]
ax_hist.text(
        0.02,
        0.02,
        "\n".join(stats_lines),
        transform=ax_hist.transAxes,
        ha="left",
        va="bottom",
        fontsize=9,
        bbox=dict(boxstyle="round", fc="white", ec="0.5", alpha=0.9),
    )

    # ------------------------------- footers --------------------------------
foot_scale = (
        f"Réduction par médiane (gridsize={args.gridsize}, mincnt={args.mincnt}). "
        f"Échelle: vmin={vmin:.6g}, vmax={vmax:.6g}  (percentiles {p_lo}-{p_hi})."
    )
foot_stats = (
        f"Stats globales: median={med:.2f}, mean={mean:.2f}, std={std:.2f}, "
        f"p95={p95:.2f} {exp_txt} [rad]. N={N}, cellules actives (≥{args.mincnt}) = "
    )

    # (subplots_adjust n'affecte pas add_axes, on l'utilise juste pour la bbox globale)
fig.subplots_adjust(
        left=0.07, right=0.96, top=0.96, bottom=0.12, wspace=0.34, hspace=0.30
    )
fig.text(0.5, 0.053, foot_scale, ha="center", fontsize=10)
fig.text(0.5, 0.032, foot_stats + f"{n_active}/{N}.", ha="center", fontsize=10)

    # ------------------------------- sortie ---------------------------------
os.makedirs(os.path.dirname(args.out), exist_ok=True)
fig.savefig(args.out, dpi=args.dpi, bbox_inches="tight")
print(f"[OK] Figure écrite: {args.out}")

if args.manifest:
        man_path = os.path.splitext(args.out)[0] + ".manifest.json"
        manifest = {
            "script": "plot_fig06_residual_map.py",
            "generated_at": pd.Timestamp.utcnow().isoformat() + "Z",
            "inputs": {
                "csv": args.results,
                "m1_col": args.m1_col,
                "m2_col": args.m2_col,
            },
            "metric": {
                "name": args.metric,
                "absolute": bool(args.abs),
                "orig_col": args.orig_col,
                "recalc_col": args.recalc_col,
                "phi_ref_col": args.phi_ref_col,
                "phi_mcgt_col": args.phi_mcgt_col,
            },
            "plot_params": {
                "gridsize": int(args.gridsize),
                "mincnt": int(args.mincnt),
                "cmap": args.cmap,
                "vclip_percentiles": [p_lo, p_hi],
                "vmin_scaled": float(vmin),
                "vmax_scaled": float(vmax),
                "scale_exp": int(args.scale_exp),
                "threshold_rad": float(args.threshold),
                "figsize": [fig_w, fig_h],
                "dpi": int(args.dpi),
            },
            "dataset": {"N": int(N), "n_active_points": int(n_active)},
            "stats_scaled": {
                "median": med,
                "mean": mean,
                "std": std,
                "p95": p95,
                "fraction_abs_gt_threshold": frac_over,
            },
            "figure_path": args.out,
        }
        with open(man_path, "w", encoding="utf-8") as f:
            json.dump(manifest, f, indent=2)
        print(f"[OK] Manifest écrit: {man_path}")


if __name__ == "__main__":
    main()
